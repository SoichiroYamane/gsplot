{"cmd": "from typing import Union\nfrom enum import Enum\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom .store import Store\n\n\nclass Axes:\n    _axes: list = []\n\n    def __init__(self):\n        print(\"Axes\", self._axes)\n        pass\n\n    @property\n    def axes(self):\n        return Axes._axes\n\n    @axes.setter\n    def axes(self, axes: list):\n        if not isinstance(axes, list):\n            raise TypeError(f\"Expected type list, got {type(axes).__name__}\")\n        self._axes = axes\n\n\nclass Unit(Enum):\n    MM = \"mm\"\n    CM = \"cm\"\n    IN = \"in\"\n    PT = \"pt\"\n\n\nclass UnitConv:\n    def __init__(self):\n        self.conversion_factors = {\n            Unit.MM: 1 / 25.4,\n            Unit.CM: 1 / 2.54,\n            Unit.IN: 1,\n            Unit.PT: 1 / 72,\n        }\n\n    def convert(self, value: float, unit: Unit):\n        if unit not in self.conversion_factors:\n            raise ValueError(\"Invalid unit\")\n        return value * self.conversion_factors[unit]\n\n\nclass Figure:\n    def __init__(\n        self,\n        store: Union[bool, int] = False,\n        size: tuple = (300, 300),\n        unit: Unit = Unit.PT,\n        mosaic: str = \"no_mosaic\",\n        clear: bool = True,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Figure class to manage the saving of plots and additional functionality.\n\n        Parameters\n        ----------\n        store : bool or int (0 or 1)\n            If True or 1, save the plot to a file. If False or 0, do not save the plot. Default is False.\n        \"\"\"\n        self.store = Store(store)\n        print(\"Figure\", self.store.store)\n\n        self.size = size\n        self.unit = unit\n        self.mosaic = mosaic\n        self.clear = clear\n\n        self.axes = Axes()\n\n    def modify_axes(self, axes: Axes):\n        \"\"\"\n        Modify the axes of the plot.\n\n        Parameters\n        ----------\n        axes : Axes\n            The axes to modify.\n        \"\"\"\n        self.axes.axes = axes\n        print(\"modify_axes\", self.axes.axes)\n\n    def _open_figure(self, *args, **kwargs):\n        \"\"\"\n        Create axes for the plot.\n        \"\"\"\n        if self.clear:\n            plt.clf()\n        plt.gcf().set_size_inches(\n            *(np.array(self.size) / self.unit_conv.convert(self.unit))\n        )\n\n        if self.mosaic != \"no_mosaic\":\n            for p in sorted(plt.gcf().subplot_mosaic(self.mosaic, **kwargs).items()):\n                print(p)\n            structures = [\n                p[1]\n                for p in (\n                    sorted(plt.gcf().subplot_mosaic(self.mosaic, **kwargs).items())\n                )\n            ]\n            return structures\n\n\nif __name__ == \"__main__\":\n    fig = Figure(store=1, size=(89, 60), unit=Unit.PT, mosaic=\"AABB\")\n\n\n\"\"\"\ndef GioFigure(\n    SaveEnabled=True, s=(89, 60), fig_type=\"paper\", mosaic=\"no_mosaic\", *args, **kwargs\n):\n    coff_inch_to_pt = 100 * 0.025400000000000002 * 28.3465\n    plt.clf()\n    if fig_type == \"paper\":\n        mm_scale = 1 * coff_inch_to_pt\n    # 20 pt in keynote (1920*1080) # more than s = 36\n    elif fig_type == \"presentation\":\n        mm_scale = coff_inch_to_pt * 2\n    elif fig_type == \"poster\":\n        mm_scale = 1.8 * coff_inch_to_pt\n    elif fig_type == \"Yajian\":\n        mm_scale = 2 * coff_inch_to_pt\n    elif fig_type == \"keynote\":\n        mm_scale = 2.5 * coff_inch_to_pt\n    else:\n        raise RuntimeError(\"fig_type not among [paper, presentation, poster]\")\n\n    global GioSaveEnabled\n    GioSaveEnabled = SaveEnabled\n\n    if GioSaveEnabled:\n        if \"figsize\" in kwargs:  # A standard figsize is given\n            plt.figure(*args, **kwargs)\n        else:\n            # changed Mar. 9th, 2022 by SY\n            # print(np.array(s) / mm_scale)\n            # plt.figure(figsize=(np.array(s) / mm_scale), *args, **kwargs)\n            plt.gcf().set_size_inches(*(np.array(s) / mm_scale))\n    else:\n        plt.clf()\n        if \"figsize\" in kwargs:  # A standard figsize is given\n            plt.gcf().set_size_inches(*kwargs[\"figsize\"])\n        else:\n            plt.gcf().set_size_inches(*(np.array(s) / mm_scale))\n\n    if mosaic != \"no_mosaic\":\n        # items => keys is also fine\n        structures = [\n            p[1] for p in (sorted(plt.gcf().subplot_mosaic(mosaic, **kwargs).items()))\n        ]\n        return structures\n\"\"\"", "cmd_opts": " --cell_id=NONE", "import_complete": 1, "terminal": "nvimterm"}